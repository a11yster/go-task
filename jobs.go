package gotask

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
)

// DefaultQueue is the default queue name used when no queue is specified in JobOpts
const DefaultQueue = "gotask:tasks"

// defaultMaxRetry is the default maximum retry count
const defaultMaxRetry uint32 = 1

// Status constants define the lifecycle states of a job
const (
	// StatusStarted is the initial state when a job is pushed onto the broker.
	// This is set immediately when Enqueue() is called.
	StatusStarted = "queued"

	// StatusProcessing is set when a worker picks up the job and starts executing it.
	StatusProcessing = "processing"

	// StatusFailed is set when a job completes with an error after all retries are exhausted.
	StatusFailed = "failed"

	// StatusDone is set when a job completes successfully without errors.
	StatusDone = "successful"

	// StatusRetrying is set when a job fails but will be retried.
	// This is a temporary state before re-enqueuing.
	StatusRetrying = "retrying"
)

type Job struct {
	// Task is the name of the registered handler/processor.
	// This must match a name registered via RegisterProcessor().
	Task string

	// Payload is the arbitrary byte data passed to the handler.
	// The handler is responsible for unmarshaling this
	Payload []byte

	// Opts contains configuration options for this job.
	Opts JobOpts

	// OnSuccess contains jobs that should be enqueued if this job succeeds.
	OnSuccess []*Job

	// OnError contains jobs that should be enqueued if this job fails.
	OnError []*Job
}

type JobOpts struct {
	// ID is an optional unique identifier for the job.
	// If empty, DefaultMeta() will generate a UUID.
	// This allows clients to track jobs by a known ID.
	Id string

	// Queue is the name of the queue where this job will be enqueued.
	// If empty, DefaultQueue is used.
	Queue string

	// ETA is when the job should be executed.
	// If zero, the job is enqueued immediately.
	ETA time.Time

	// MaxRetries is the maximum number of times to retry the job if it fails.
	MaxRetries uint32

	// Schedule is a cron expression for recurring jobs.
	Schedule string

	// Timeout is the maximum duration the job handler can run.
	Timeout time.Duration
}

type Meta struct {
	// ID is the unique identifier for this job instance.
	// This is set from JobOpts.ID or generated by DefaultMeta().
	Id string

	// OnSuccessIDs stores the IDs of jobs enqueued after this job succeeds.
	OnSuccessIds []string

	// Status is the current lifecycle state
	Status string

	// Queue is the queue name where this job is/was enqueued.
	Queue string

	// Schedule is the cron expression if this is a recurring job.
	Schedule string

	// MaxRetry is the maximum retry count
	MaxRetry uint32

	// Retried is the current number of retries attempted.
	Retried uint32

	// PrevErr stores the error message from the last failed attempt.
	PrevErr string

	// ProcessedAt is the timestamp when the job status was last updated.
	ProcessedAt time.Time

	// PrevJobResult contains the result bytes from the previous job in a chain.
	PrevJobResult []byte
}

type JobCtx struct {
	context.Context

	Meta Meta

	store Results
}

func (c JobCtx) Save(b []byte) error {
	return c.store.Set(c, c.Meta.Id, b)
}

// DefaultMeta creates a Meta struct with default values filled in.
// This is called when a job is enqueued to initialize its metadata.
func DefaultMeta(opts JobOpts) Meta {
	if opts.Id == "" {
		opts.Id = uuid.NewString()
	}

	if opts.Queue == "" {
		opts.Queue = DefaultQueue
	}

	return Meta{
		Id:       opts.Id,
		Status:   StatusStarted,
		Queue:    opts.Queue,
		MaxRetry: opts.MaxRetries,
		Schedule: opts.Schedule,
	}
}

// NewJob creates a new Job with validation.
// This is the constructor that clients use to create jobs.
func NewJob(handler string, payload []byte, opts JobOpts) (Job, error) {
	if handler == "" {
		return Job{}, fmt.Errorf("handler name cannot be empty")
	}

	if opts.Queue == "" {
		opts.Queue = DefaultQueue
	}

	return Job{
		Task:    handler,
		Payload: payload,
		Opts:    opts,
	}, nil
}

// JobMessage is the serialized form of a job that's sent through the broker.
// It combines the Job (what to do) with Meta (runtime state).
type JobMessage struct {
	// Meta is embedded, so JobMessage has all Meta fields directly accessible
	Meta

	// Job is a pointer to the actual job definition
	Job *Job
}

// message() is a helper method on Job to create a JobMessage.
// This is called internally by Enqueue() to prepare the job for serialization.
func (j *Job) message(meta Meta) JobMessage {
	return JobMessage{
		Meta: meta,
		Job:  j,
	}
}
